Что нужно:
1. Уменьшить размеры передаваемых каждый раз файлов.
2. Сократить необходимость сливать файлы и сделать это слияние по возможности автоматическим.
3. Вообще исключить необходимость сливать файлы.
4. Позволить нескольким Мирандам прозрачно работать параллельно.

Т.к. контакты и настройки едины, они должны лежать отдельно от сообщений, в общем файле параметров.

Этот файл придётся уметь сливать. Однако изменения в нём должны происходить не слишком часто. В хорошем сценарии изменения с одного компа быстро синхронизируются на другой (файл маленький). Другой замечает изменения и прозрачно перезагружает (обнаруживая удалённые и добавленные контакты, изменения).

Файлы сообщений надо делить на несколько файлов. Есть варианты:

Делить по годам (2016, 2017, 2018) или по годам-месяцам (2018.08). Сокращает объём передаваемых данных, но не снимает полностью риск конфликтов (например, забыли включить BTSync).

Делить по компьютерам. У каждого компьютера свой уникальный ID; только этот файл считается "пишущим", а остальные только на чтение. Риск конфликтов по замыслу исключён, но объём передаваемых данных полный.
В этой схеме возникает ряд сложностей:
- Дублирование сообщений. Компьютер Б регистрирует входящее повторно, ещё не зная, что оно недавно добавилось в лог компьютера А. Не страшно: будет редко и пусть дублируются (можно отфильтровать при показе).
- Удаление сообщений и хуже того, отметка как прочитанных (и букмарки). Метка ставится в теле сообщения, которое легко может быть в "чужом" файле.

Что можно сделать с последней проблемой?
1. Всё же писать в чужие файлы, просто редко.
  Даже в сочетании с разными другими облегчающими приёмами (разбиение по месяцам, уменьшающее размер файла), легко представить сценарий, где несколько дней лога А не синхронизировались на нетбук Б, затем на нетбуке были сделаны какие-то изменения в лог А - например, сообщения автоматически помечены как прочтённые - и лог на компьютере А ими затёрт.

2. Писать в свои файлы маркеры.
  В этом варианте разрешаем писать только в свой файл. Если мы хотим пометить запись как прочтённую или удалённую, мы копируем её к себе (или же какой-то идентифицирующий заголовок) и ставим такой флаг.
  Состояние записи на любом из компьютеров в таком случае будет совокупностью этих флагов.
  Плюсы: каждый пишет только в свой файл.
  Минусы: 
  - состояние записи может странно изменяться по мере того, как загружаются частичные логи
  - если на одном компьютере букмарк поставили, на другом сняли, то как из совокупных логов очевидно, установлен он в итоге или снят? В одном логе такая метка, в другом другая.

3. Вести лог операций.
4. Аддендумы к чужим файлам (по сути тот же лог операций).
  Каждый файл обслуживается только "своим" компьютером. Но другие компьютеры могут создавать файлы "этот_файл.имя_компьютера.dat". Это аддендумы, они содержат предлагаемые дополнения к файлу от лица соотв. компьютера. Каждый пишет только свой.
  По-видимости, все компьютеры должны читать все журналы и все аддендумы и динамически составлять из них полную картину. В журнале однако есть по каждому аддендуму номер последней внесённой записи, соответственно, более ранние записи можно уже не смотреть. Компьютер-владелец журнала вносит новые записи из аддендумов и обновляет журнал.
  Минусы: супер-запутано и по-прежнему непонятно, что делать, если в нескольких аддендумах противоречивая информация. Судить по времени? Ну так это можно и во варианте 2.

Кроме того, толком не продуман случай дублирования записей в отношении "прочитан/не прочитан" и букмарок. Куда ставится букмарка, в какой из дублей?

Можно такую комбинированную схему. Каждый компьютер ведёт только один файл, свой. (Ну или несколько, при разбиении). У каждого компьютера может быть, а может не быть собственная копия сообщения. Если она есть, в ней должно быть UTC-время последнего обновления.
Когда нужно внести правку в сообщение, компьютер находит или создаёт собственную его копию, вносит правку и отмечает время.
Правильным считается версия с самым новым временем из всех файлов.